#!C:/Tools/Python38/python.exe
"""
Generate a policy stub from a list of CloudTrail Events. This policy can then 
be attached to a role and passed to a CICD pipeline.
NOTE: That the policy is not scoped to the resource of the stack that is updated / maintained  
"""
from argparse import ArgumentParser, RawTextHelpFormatter
from os import listdir
from os.path import join, isdir, isfile, basename
import boto3
import gzip
import json
import logging
import re
import uuid
import sys

logging.basicConfig(level=logging.WARN)
logger = logging.getLogger()

s3 = boto3.client('s3')
iam = boto3.client('iam')

valid_actions = re.compile(r"(.*):([^0-9]+)([0-9]{8}.*)?")


def _generate_policy_from_actions(actions):
    """Return a list of actions."""
    unique_actions = list(set(actions))
    short_actions = list(map(lambda a: valid_actions.sub(r"\1:\2", a.replace('.amazonaws.com', '')), unique_actions))
    user_actions = list(filter(lambda a: a not in ("cloudtrail:StartLogging", "cloudtrail:StopLogging"), short_actions))
    sid = str(uuid.uuid4())
    return {
        "Version": "2012-10-17",
        "Statement": [{
            "Sid": f"CloudFormationRoleGenerator-{sid}",
            "Effect": "Allow",
            "Action": list(sorted(user_actions)),
            "Resource": "*"
        }]
    }


def generate_policy(args):
    """Main function."""
    if not isdir(args.logs_dir):
        raise ValueError(f"Invalid '--log-dir' parameter: no such directory {args.logs_dir}")
    onlyfiles = [f for f in listdir(args.logs_dir) if isfile(join(args.logs_dir, f))]
    user_records = []
    actions = []
    for f in onlyfiles:
        logger.debug(f"Parsing {f} ...")
        with gzip.open(join(args.logs_dir, f), "rb") as f:
            records = json.loads(f.read().decode('utf-8'))['Records']
            records = list(filter(lambda r: r.get('userIdentity', {}).get('userName', '') == args.username, records))
            records = list(sorted(records, key=lambda x: x['eventTime']))
            actions.extend(list(map(lambda r: f"{r['eventSource']}:{r['eventName']}", records)))
            user_records.extend(records)
    if args.user_events_output:
        with open(args.user_events_output, "w") as user_events_output:
            json.dump(user_records, user_events_output, indent=2)

    user_policy = _generate_policy_from_actions(actions)
    if args.validate:
        logger.debug("Validating policy ...")
        response = iam.create_policy(
            PolicyName=str(uuid.uuid4()),
            Path='/',
            PolicyDocument=json.dumps(user_policy, indent=2),
            Description=f"Policy Generated by {basename(__file__)}"
        )
        policy_arn = response.get('Policy', {}).get('Arn', None)
        if policy_arn:
            iam.delete_policy(PolicyArn=policy_arn)
        else:
            logger.warn("Failed to create the policy. Check if it is valid")
    if args.user_policy_output:
        with open(args.user_policy_output, "w") as user_policy_output:
            json.dump(user_policy, user_policy_output, indent=2)
    else:
        print(json.dumps(user_policy, indent=2))


def parse_command_line():
    """Parse the command line arguments."""
    parser = ArgumentParser(
        prog='generate_policy',
        description=__doc__,
        formatter_class=RawTextHelpFormatter)
    parser.add_argument(
        '--logs-dir',
        help='The path where the logs were downloaded',
        metavar="DIR",
        required=True)
    parser.add_argument(
        '--username',
        help='The EventUsername used to filter the events',
        required=False, default='StackDeveloper')
    parser.add_argument(
        '--user-events-output',
        metavar="FILE",
        help='If set, writes the user events records to file',
        required=False)
    parser.add_argument(
        '--user-policy-output',
        metavar="FILE",
        help='If set, writes the policy to file',
        required=False)
    parser.add_argument(
        '--validate',
        action='store_true',
        help='If set try to validate the Policy by creating a policy in IAM',
        required=False)
    parser.set_defaults(func=generate_policy)
    return parser.parse_args()


def main():
    args = parse_command_line()
    try:
        return args.func(args)
    except Exception as e:
        logging.error(e, exc_info=True)
        return 1


if __name__ == '__main__':
    sys.exit(main())
